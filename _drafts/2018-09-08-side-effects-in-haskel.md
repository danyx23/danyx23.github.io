## Side effects in Haskell

To understand his approach, I think it is useful to first look at how Haskell deals with functions that have side effects vs pure ones and why that is an interesting feature (especially if you are unfamiliar with Haskell). Most mainstream languages that have static types are imperative - you can perform side effects like reading files or communicating via a network at any point in your program and the types can't tell you anything about this. Haskell on the other hand started out as a pure functional language where you simply couldn't do any IO. This allowed Haskell to develop a few great features but you were not really able to perform any side effects which was admittedly not terribly useful. Then with a nice alignment of a few good ideas that were incorporated into Haskell it gained a way of performing side effects using something called Monads. A lot has been written about Monads but they are really not terribly exciting - all you need to know for the purpose of this article is that they are a way of sequencing chunks of code with some sideeffects (they can be used for other things but this is one of their main uses). If you know a language that has syntactic sugar for async io (e.g. C# or Python from version 3.4 or recent Javascript proposals) then you have already used this concept - you mark a method as `async` so the compiler/interpreter will allow you to `await` some value. Monads in Haskell are a more generic version of the same idea.

What does this look like in practice? In Haskell, type signatures separate the parameters to functions with arrows and the last item is the return type.

Let's look at two versions of a function `repeatString` that takes a string and an int and returns the string multiplied n times would have a type signature like this:

```haskell
repeatStringPure :: String -> Int -> String

repeatStringWithSideeffects :: String -> Int -> IO String
```

The difference is that the return type of the first is just a String and so we know it is pure, whereas the second returns `IO String`. In the first one the compiler will not allow you to use any function that performs side effects, because all of them require the return type to be IO. Pure functions can't call side effectful functions, but of course side effectful functions can call pure functions. The main entry point of your applications of course has a return type of IO so that you can call side effectful functions from there.

Why is this useful? Well, pure functions have a few very useful properties. For one, the are idempotent, meaning that if you call them again with the same arguments, they will return the same result. This is great for testing because pure functions will never behave differently depending on the environment and there is no need to mock anything. Because they can't perform any side effects you know that all they can do is compute a value and you don't have to inspect every function in a call hierarchy to make sure that there is no unexpected network traffic etc happening deep inside.

You may wonder how useful this can be in practice - if you are used to mainstream, imperative languages, then it may seem like pure functions can only be useful for some math operations but in most real world cases you would need side effects most of the time. It turns out that you can actually treat a large part of your app as pure if you think of your entire application state a (pretty complex) value of some type and therefore as data, and then also treat all events that can happen in your app as data and model the required side effects as a sort of message to the side effectful part of your application (which can then be very small). This is basically what Elm has popularized and which was then taken up even in imperative Javascript with the popular React/Redux combination. The great thing about this is that it allows you to test your business logic very well because all you need to do is write a small alternative implementation for the side effectful part.
